
# File management

:e              reload file
:q              quit
:q!             quit without saving changes
:w              write file
:w {file}       write new file
:x              write file and exit

# Movement

    k
  h   l         basic motion
    j

w               next start of word
W               next start of whitespace-delimited word
e               next end of word
E               next end of whitespace-delimited word
b               previous start of word
B               previous start of whitespace-delimited word
0               start of line
$               end of line
gg              go to first line in file
G               go to end of file
gk		        move down one displayed line
gj		        move up one displayed line

# Insertion
#   To exit from insert mode use Esc or Ctrl-C
#   Enter insertion mode and:

a               append after the cursor
A               append at the end of the line
i               insert before the cursor
I               insert at the beginning of the line
o               create a new line under the cursor
O               create a new line above the cursor
R               enter insert mode but replace instead of inserting chars
:r {file}       insert from file i.e. read (file)

# Editing

u               undo
yy              yank (copy) a line
y{motion}       yank text that {motion} moves over
Y               yank from cursor to end of line (personal mapping)
p               paste after cursor
P               paste before cursor
<Del> or x      delete a character
dd              delete a line
d{motion}       delete text that {motion} moves over

# Search and replace with the `:substitute` (aka `:s`) command
# :substitute
:s/foo/bar/	replace the first match of 'foo' with 'bar' on the current line only
:s/foo/bar/g	replace all matches (`g` flag) of 'foo' with 'bar' on the current line only
:%s/foo/bar/g	replace all matches of 'foo' with 'bar' in the entire file (`:%s`)
:%s/foo/bar/gc	ask to manually confirm (`c` flag) each replacement 

# :global
# :g executes the given command on every line of the file hence global
:g/^$/ d        delete all empty lines in a file
:g/^$/,/./-j    reduce multiple blank lines to a single blank



# Preceding a motion or edition with a number repeats it 'n' times
# Examples:
50k         moves 50 lines up
2dw         deletes 2 words
5yy         copies 5 lines
42G         go to line 42

### DONAGHS ###

#####                   PLUGINS                 ########
# easymotion
,/
# emmet
! <C-y>,                            # Note the , at the end.
div>p#foo>ul>li*4 <C-y>,

# goyo & limelight
F9
# or
:Goyo

# Check installed plugins
:scriptnames
:help local-additions

# Plugins
# location of info on my vim plugins on zim-wiki
/home/donagh/sd64/zim/Computer/LINUX/1Linux_Live_USB/02a_install_extras/10vim_settings/vim_plugins.txt
eg cd to above folder and ->% grep <surround>

# list plugins
cat /home/donagh/PORTABLE_ENV/vim/plugins/my_vim_plugins
# or 
# see /home/donagh/PORTABLE_ENV/vim/vimrc_files/plugins.vim 

# To install a new plugin
# 1. git clone into /home/donagh/PORTABLE_ENV/vim/dotvim/plugins (which is symlinked to ~/.vim)
# 2. vim /home/donagh/PORTABLE_ENV/vim/vimrc_files/plugins.vim " rem: I can use gf to open that file!
# 3. add e.g. Plug 'https://github.com/vim-airline/vim-airline-themes.git' under call plug#begin('/home/donagh/.vim/plugins')
# 4. run :PlugInstall 

# check installed / working plugins
ll $HOME/PORTABLE_ENV/vim/dotvim/plugins
# or
grep "^Plug" /home/donagh/PORTABLE_ENV/vim/vimrc_files/plugins.vim

# source for plugin recommendations
https://catonmat.net/vim-plugins


# vim surround 
# to put " around the words bear necessity - with cursor on the b of bear
' ys2w" '
# use ysiw when it's only one word " 

#  to change 'funny' to "funny"
' cs'"'


# tab navigation
gt # next tab
gT # prev tab

# Ranges
:12,34s/old/new/g   # substitute in lines 12 to 34 inclusive
12,$                # from line 12 to end of the file
.,$                 # current to end
%                   # all file
1,$                 # equivalent to %

# tab buffers
vim -p file1.text file2.txt # open files in separate tabs
tabe # edit a new file
H   # previous filetab - alias for gt
L   # next filetab - alias for gT

# " open file at line 23
vim +23 <filename>

# navigate tabs
tab left H
tab right  L



# Splits
hor. split  : <Leader> H
ver. split  : <Leader> O
swap splits : Ctrl W Shift R
equalize split : Ctrl W =
maximize split   : Ctrl W _ (hor. split)
maximize split   : Ctrl W | (ver. split)
resize split     :res +5 or :vert res -5

# Terminal in vim
:sp |:terminal

# Turn terminal into a vim file
<C-w> <S-n>
# To exit 
# <C-w> <S-i>
# 

# Navigation
C-B --> back one pane
C-F --> forward one pane

# Open file under cursor - custom keybinding
,vf # open vert. split
,hf # open hor. split

# Insert filename - relative to starting folder. In INSERT MODE:
<C-r>%
# Insert filepath. In NORMAL MODE:
,d 
# Insert filepath. In INSERT MODE:
,n


# Remember to use Notes (addon) (defunct now with org-mode etc.)
:Note

# show lines with matching word under cursor
[I

# find non-ascii characters in a vim file
/[^a-zA-Z0-9-: #\/\.,)("']  # Donaghs recipe
/[^\d0-\d127]               # Where d0 represents the first ASCII and d127 the 128th

# uniquify lines in a text
:sort u

# insert a range of lines from another file
:put =readfile('/path/to/foo/foo.c')[146:226]
# or
:r! sed -n 3,7p /path/to/foo/bar.md

# to read in the 3 lines After 'CHALLENGE' in the specified file
:r! grep -A3 "CHALLENGE" /path/to/foo/bar.md

# digraphs :h digraphs
Ctrl K =e <-- euro OR Ctrl K Eu <-- euro

# online vim docs
https://www.vim.org/docs.php

# doom-emacs like save file
:w[SPC] # which is SPC w SPC as I have SPC mapped to : and the muscle memory carries over to doom-emacs. 


# bulk rename files using vim and ranger
-> % vidir
# cheat rename
#
# change the point at which a sentence wraps
set textwidth=79
#
# get info on character under cursor
ga
g8

# find non-ascii chars in the file
/[^\x00-\x7F]

# replace a non-ascii character 
# example  
# and replace that with the ascii "
# 1. cursor over the character and yl to yank into the " register
# :s/<Ctrl-R ">/"/g ie after the first / press Ctrl-R then " to paste
# the contents of the " register into the command line
# after pressing enter the substitution should be made
# for the whole file
:%s/<Ctrl-R ">/"/g 

# to enter this non-ascii character --> ‚Äù
# in insert mode
Ctrl-V u 201d


# to identify what unicode number ‚Äù is place cursor on it then type 
ga
# the number after the word Hex is 201d 

# resize windows
# Maximize current window
C-W _
# Equalize windows
C-W =
# Incrementally in- de- crease window
C-W +
C-W -
# Increase current window by 10 units
10 C-W +

# EMOJIS
In vim the following will get closest to 'real' emojis

Press insert (i) then Ctrl-V i.e. <c-v> and type in U0001f600 or whatever your choice is

<c-v>U0001f600
üòÄ
<c-v>U0001f601  = 128513 (Decimal)
üòÅ
<c-v>U0001f602
üòÇ
<c-v>U0001f603
üòÉ
<c-v>U0001f604  = 128516 (Decimal)
üòÑ
<c-v>U0001f605
üòÖ
<c-v>U0001f606
üòÜ


# DELETE BLANK LINES
:g/^\s*$/d

# insert filename / filepath
<C-r>%  # full filepath - insert mode
,d      # normal mode

# In the CLI
# <command> | vim - opens a vim file with the output of <command>
-> % ll | vim -

# get the UTF-8 code for the letter under the cursor
# https://vi.stackexchange.com/questions/555/see-the-unicode-code-point-of-the-current-character
ga
g8


# see how quickly Vim starts without your existing configuration:
vim --clean --startuptime clean.log <fileName>


####

# To edit a macro called @l 
"lp                 # paste the macro into the buffer to edit it
# yada-yada         # the macro in @l now pasted into the current buffer NOTE: this line contains non-utf8 characters
# yada-yada-yada    # revised macro after editing NOTE: this line contains non-utf8 characters
B"hyE               # command to edit macro and replace it with the previous lin e but place the macro now in @h


# live update of <filename> in a pdf viewer with the <filename.md> open in say, Okular
:!pandoc % -o %:t:r.pdf

# use vim with NO packages
vim -u NONE <filename>
# or
vim -u NORC <filename>

# use "= to print the $VIMRUNTIME into the current buffer
# "=&rtp
# then press p for paste
#
# PWD paste current full filepath into current buffer
# Consider getbufinfo() for loads of info
# normal mode
:put=expand('%:p')<cr> # set to <leader>d for directory 
# insert mode
<C-R>=getcwd()<cr> # set to <leader>dp 
# followed by
<C-R>%



# go to a file
# gf with the cursor on the following line will open that file in a new tab (see .vimrc)
~/DONAGHS/personal/journal/2021/11/26-11.md
# Ctrl o reverts to departure file
# URL link
# gx with the cursor on the following line will open that resource in a browser
https://github.com/jceb/vim-orgmode/blob/master/doc/orgguide.txt

# python spaces / tabs
:retab # fixes tabs / spaces
:set lcs+=space: # shows a . for each space
:set list # displays the .
:set nolist # hides the .
plugin --> git clone https://github.com/Yggdroot/indentLine
# For code indented with tabs I think there is no need to support it, because you can use :set list lcs=tab:\|\

# sudo trick
:w !sudo tee %

# NUMBERED LIST 
# Method #1
# Visual select lines and ,n 
#
# Method #2
# record this macro and start with cursor on first line
# The list should have a blank line at the end
# The actual keys are the entire sequence: ^<C-V>}kI0. <Esc>gvg<C-A> (Try it here!)
^^V}<80>kuI0. ^[<80><fd>ag

# Method #3
# Select your lines in visual mode with: v, then type/copy into ex mode 
:s/^\s*\zs/\=(line('.') - line("'<")+1).'. '

# EDIT AN EXISTING MACRO 
# make a new scratch buffer to edit the macro in <leader>c   c because s c ratch  has 2 letter c's in it and s is taken
# this function is defined in my vimrc
# move to the scratch buffer <C-j>
# paste the contents of the relevant macro e.g. if macro is in the d register do this: "dp
# do the edit then yank the newly-edited macro back into the register: "dyy
# et voil√°

# View & Edit the ex Mode history
# in normal mode
q:

# the cgn trick to change any no. of occurences of a word 
# cursor on word, *, then cgn, then .   That last . is the repeat character not a period!
# cgn = change goto next (word)

# when searching I have / mapped to /\v to engage very magic search which means '[ (' etc. don't need to be escaped 
#
# vim path
# path is a list of directories which will be searched when using the gf, [f, ]f, ^Wf, :find, :sfind, :tabfind and other commands, 
# provided that the file being searched for has a relative path (not starting with "/", "./" or "../").
:set path= (then TAB)
path=.,/usr/include,,           :: the default path(s) for vim
# to add, say, ~/REPOS/books to the path
:set path+=~/REPOS/books        :: can be set in .vimrc; it means that :find etc. will search in the given directory for the file.

# find  a file
:find 2Read.md
# find a file and open in a new split
:sfind 2Read.md

# REGEX 
# :h regexp and http://vimregex.com/
# wordboundary \< and \>
:s/\<vim\>/VIM/g
# \zs & \ze
:s/\zsREPOS\ze/REPOSITORIES/g
# Very Magic in substitions allows not escaping the ( and )
# example1: repos (repositories) REPOSITORIES :: try the below on this lin
:s/\v(repos)/\1zz/ig
# example2: foo foo foo foo :: the following search will match only the final foo(d)
/.*\zsfoo
# example3: Lookbehind - find bar but only if it is preceded with foo
# foobar
# bazbar
# foobar
# quxbar
/\v(foo)@<=bar

# to edit commands history 
Ctrl-f  (in command mode)
q:      (in normalmode)

# edit the contents of a dir in a vim buffer
# Method 1 
vidir
# Method 2 - uses basic vim!
:r !ls

# turn off the highlight to the underscore in markdown. NOTE: Solved in .vimrc/Markdown section.
:hi link markdownError Normal


# to convert a file to pdf in vim 
map <F5> :!pandoc % -o %:t:r.pdf<cr>    # NOTE: needs a pdf-engine like pdflatex; LaTex or TexLive may be used 
# The :t and :r are called filename modifiers.
#
#
#
# _____________________________________________________________________________
# FUNCTIONS - examples
# open my journal in a new tab
function! Myjournal()
    let year = strftime('%Y')
    let month = strftime('%m')
    let day = strftime('%d')
    let path = '/run/media/donagh/01d4c077-4709-4b5b-9431-087bc9060d68/DONAGHS/personal/journal/'.year.'/'.month
    let filen =  path.'/'.day.'-'.month.'.md'

    execute ":tabe ".filen
endfunction

# open my journal in a new tab
nnoremap mj :call Myjournal<cr>

# simple arithmetic function
let g:sum=0
function SumNumbers(num1,num2)
    let l:sum = a:num1+a:num2
    "check if previous sum was lower than this
    if g:sum < l:sum
        let g:sum=l:sum
    endif
endfunction

# test code
call SumNumbers(3,4)
# this should return 7
echo g:sum

# _____________________________________________________________________________

# JUMPS
# jump lists     jumps are remembered in the jump list saurce of pnai 
# :changes      lists the changes made to the file; use g; and g, to navigate this in normal mode
# :jumps        jumps are things like searches, finding marks; to navigate the jumps use Ctrl-o (backwards) and Ctrl-i (forwards) : will go to other files
# A "jump" is a command that normally moves the cursor several lines away.
# The following commands are "jump" commands: "'", "`", "G", "/", "?", "n", "N", "%", "(", ")", "[[", "]]", "{", "}", ":s", ":tag", "L", "M", "H" 
#
# SPELLING
# :setlocal spell   'misspelt' words will be underlined. Navigate using [s (previous) ]s (next)
# Ctrl-N            Used in Insert mode; drop-down list of word suggestions; insert mode; word must already be used earlier in the buffer; 
# autocomplete / spelling
# first few letters of a word in the text then (Insert mode) Ctrl+P or Ctrl+N 

# zg                add words to spellfile; this file will be created at /home/donagh/.vim/spell/en.utf-8.add (no .spl extension)
# spelling - get corrections
# z=                in Normal mode, z= will bring up big list of suggestions for spell correction; use 1z= to select the first one; 
#                   (with or without :set spell) try it - z=spelling
# 
# MACROS
# In Insert mode Ctrl-R <letter>   put the contents of register <letter> into the buffer; useful for making re-usable functions or editing macros.
 

# SESSIONS
# Open file where you left off 
# :mksess! and open with vim -S
# To go to the same place you were in a document after closing, use vim sessions. You issue a ":mksess!" and vim will drop a Session.vim file in your current directory. This will store all the docs you had open and where you were in them. Then when you start vim, do "vim -S" to take you back to exactly where you were.
# Not sure about the above. I have an alias vx which opens a file called scratch.md and I add :mksession! to allow me to return to the position on opening


# INFO 
# To display file data - for word count etc.
# Use airline or in normal mode g C-g
 
# VIM PLUG
# A modern plugin manager. Started using this 2022-02-05
# install
# cd ~/.vim/autoload
curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
	https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

# INSTALL NEW PLUGIN - 2 steps
# cd ~/PORTABLE_ENV/vim/dot_vim/plugins and then (usually)
-> % git <git path to repo>
#then in  /home/donagh/PORTABLE_ENV/vim/vimrc_files/plugins.vim 
# add e.g.
Plug 'https://github.com/vim-airline/vim-airline.git'

# COMMAND INFOLINE
# the command info line - that empty line below the airline strap
# to change it's height to 2 (ie 2 lines)
:set cmdheight=2 

# DIRECTORIES
# significant directories & files
$MYVIMRC = ~/.vimrc
$VIM = /usr/share/vim
$RTP = ~/.vim

# Ctrl R, in Ex mode,  with... 
% --> Current file name
" --> Last yanked text
* --> Clipboard contents
/ --> Last search pattern

# Quickfix list and Location list
The quickfix list is a data structure that holds file positions. 
Essentially, each entry in the quickfix list consists of a file path, a line number and optional column, and a description.

Actually there are two kinds of lists: quickfix and location lists. They behave almost the same, but have the follwing differences:
There is only one quickfix list. There can be multiple location lists; one per window.
They use slightly different commands for navigation.

Action 	        Quickfix 	Location
open window 	:copen 	    :lopen
close window 	:cclose 	:lclose
next entry 	    :cnext 	    :lnext
previous entry 	:cprevious 	:lprevious
first entry 	:cfirst 	:lfirst
last entry 	    :clast

# Quickfix usage example
The quickfix list is populated when you run commands such as :grep. 
:grep ugly -r **/*.txt
This will populate the quickfix list with a list of files with the word 'ugly' in them. You can use :copen or :clist to look at the files manually.

# to get the hex of a character place cursor on character and in noral mode type
ga

# Mdash  digraph -M (often occurs when pasting in from the browser)
‚Äî  \%u2014 
#to replace with [spc]-[spc] do 
:%s/\%u2014/ - /g
# HINT :help %u
# To convert the annoying, illegible first line into the second line use @h where h contains :s/\%u2014/ - /g
1. these‚Äîfor the most part‚Äîare not good enough
2. these - for the most part - are not good enough
#to put :s/\%u2014/ - /g into the h register, use "hdd  


# later / earlier
:earlier 15 
:later 40
# Also very useful is 
g+ and g- 
# to go backward and forward in time. 
# This is so much more powerful than an undo/redo stack since you don't lose the history when you do something after an undo.

# dump, say, ls into the current buffer
# Note  :! [command] executes an external command while you're in Vim.
# But add a dot after the colon, 
:.! [command]
# and it'll dump the output of the command into your current window. Eg open a new buffer in $HOME then :. ls and the contents of $HOME will be pasted in.
#

